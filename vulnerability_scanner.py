#!/usr/bin/env python3
"""
Life Alliance Website - Vulnerability Scanner
Comprehensive security scanning for web vulnerabilities
"""

import requests
import json
import re
import sys
from urllib.parse import urljoin, urlparse
import time
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    def __init__(self, base_url="http://localhost:8000"):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Life Alliance Security Scanner 1.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
        })
        self.vulnerabilities = []
        
    def scan_headers(self):
        """Scan for missing security headers"""
        print("üîç Scanning security headers...")
        
        try:
            response = self.session.get(self.base_url)
            headers = response.headers
            
            # Security headers checklist
            security_headers = {
                'Strict-Transport-Security': 'HSTS header for HTTPS enforcement',
                'Content-Security-Policy': 'CSP header for XSS protection',
                'X-Frame-Options': 'Frame options for clickjacking protection',
                'X-Content-Type-Options': 'Content type options for MIME sniffing protection',
                'Referrer-Policy': 'Referrer policy for privacy protection',
                'Permissions-Policy': 'Permissions policy for browser API control',
                'X-XSS-Protection': 'XSS protection header',
                'Cross-Origin-Embedder-Policy': 'Cross-origin embedder policy',
                'Cross-Origin-Opener-Policy': 'Cross-origin opener policy',
                'Cross-Origin-Resource-Policy': 'Cross-origin resource policy'
            }
            
            missing_headers = []
            present_headers = []
            
            for header, description in security_headers.items():
                if header in headers:
                    present_headers.append(f"‚úÖ {header}: {headers[header]}")
                else:
                    missing_headers.append(f"‚ùå {header}: Missing - {description}")
            
            print(f"\nüìä Security Headers Scan Results:")
            print(f"‚úÖ Present: {len(present_headers)}")
            print(f"‚ùå Missing: {len(missing_headers)}")
            
            if present_headers:
                print("\n‚úÖ Present Headers:")
                for header in present_headers:
                    print(f"   {header}")
            
            if missing_headers:
                print("\n‚ùå Missing Headers:")
                for header in missing_headers:
                    print(f"   {header}")
                self.vulnerabilities.extend(missing_headers)
            else:
                print("\nüéâ All security headers are present!")
                
        except Exception as e:
            print(f"‚ùå Error scanning headers: {e}")
    
    def scan_xss(self):
        """Scan for XSS vulnerabilities"""
        print("\nüîç Scanning for XSS vulnerabilities...")
        
        # Common XSS payloads
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>',
            '<iframe src="javascript:alert(\'XSS\')"></iframe>'
        ]
        
        try:
            # Get the main page
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find forms
            forms = soup.find_all('form')
            xss_vulnerabilities = []
            
            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                
                if not action:
                    action = self.base_url
                
                form_url = urljoin(self.base_url, action)
                
                # Find input fields
                inputs = form.find_all(['input', 'textarea', 'select'])
                form_data = {}
                
                for input_field in inputs:
                    name = input_field.get('name')
                    if name:
                        form_data[name] = xss_payloads[0]  # Test with first payload
                
                if form_data:
                    try:
                        if method == 'POST':
                            test_response = self.session.post(form_url, data=form_data)
                        else:
                            test_response = self.session.get(form_url, params=form_data)
                        
                        # Check if payload is reflected
                        if xss_payloads[0] in test_response.text:
                            xss_vulnerabilities.append(f"Potential XSS in form {action}")
                    
                    except Exception as e:
                        print(f"   Warning: Could not test form {action}: {e}")
            
            if xss_vulnerabilities:
                print("‚ùå XSS Vulnerabilities Found:")
                for vuln in xss_vulnerabilities:
                    print(f"   {vuln}")
                self.vulnerabilities.extend(xss_vulnerabilities)
            else:
                print("‚úÖ No obvious XSS vulnerabilities found")
                
        except Exception as e:
            print(f"‚ùå Error scanning XSS: {e}")
    
    def scan_sql_injection(self):
        """Scan for SQL injection vulnerabilities"""
        print("\nüîç Scanning for SQL injection vulnerabilities...")
        
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' OR 1=1 --",
            "admin'--"
        ]
        
        try:
            response = self.session.get(self.base_url)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            forms = soup.find_all('form')
            sql_vulnerabilities = []
            
            for form in forms:
                action = form.get('action', '')
                method = form.get('method', 'GET').upper()
                
                if not action:
                    action = self.base_url
                
                form_url = urljoin(self.base_url, action)
                inputs = form.find_all(['input', 'textarea', 'select'])
                
                for input_field in inputs:
                    name = input_field.get('name')
                    if name and ('user' in name.lower() or 'pass' in name.lower() or 'login' in name.lower()):
                        form_data = {name: sql_payloads[0]}
                        
                        try:
                            if method == 'POST':
                                test_response = self.session.post(form_url, data=form_data)
                            else:
                                test_response = self.session.get(form_url, params=form_data)
                            
                            # Look for SQL error patterns
                            sql_errors = [
                                'mysql_fetch_array',
                                'mysql_num_rows',
                                'ORA-01756',
                                'Microsoft OLE DB Provider',
                                'ODBC SQL Server Driver',
                                'SQLServer JDBC Driver',
                                'PostgreSQL query failed',
                                'Warning: mysql_',
                                'MySQLSyntaxErrorException',
                                'valid MySQL result'
                            ]
                            
                            for error in sql_errors:
                                if error.lower() in test_response.text.lower():
                                    sql_vulnerabilities.append(f"Potential SQL injection in field {name}")
                                    break
                        
                        except Exception as e:
                            continue
            
            if sql_vulnerabilities:
                print("‚ùå SQL Injection Vulnerabilities Found:")
                for vuln in sql_vulnerabilities:
                    print(f"   {vuln}")
                self.vulnerabilities.extend(sql_vulnerabilities)
            else:
                print("‚úÖ No obvious SQL injection vulnerabilities found")
                
        except Exception as e:
            print(f"‚ùå Error scanning SQL injection: {e}")
    
    def scan_directory_traversal(self):
        """Scan for directory traversal vulnerabilities"""
        print("\nüîç Scanning for directory traversal vulnerabilities...")
        
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
        ]
        
        traversal_vulnerabilities = []
        
        try:
            # Test common file paths
            test_paths = [
                '/download',
                '/file',
                '/view',
                '/show',
                '/get',
                '/read'
            ]
            
            for path in test_paths:
                for payload in traversal_payloads:
                    test_url = f"{self.base_url}{path}?file={payload}"
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Look for signs of successful traversal
                        if ('root:' in response.text or 
                            'bin/bash' in response.text or 
                            'localhost' in response.text or
                            '127.0.0.1' in response.text):
                            traversal_vulnerabilities.append(f"Potential directory traversal at {path}")
                            break
                    
                    except Exception:
                        continue
            
            if traversal_vulnerabilities:
                print("‚ùå Directory Traversal Vulnerabilities Found:")
                for vuln in traversal_vulnerabilities:
                    print(f"   {vuln}")
                self.vulnerabilities.extend(traversal_vulnerabilities)
            else:
                print("‚úÖ No directory traversal vulnerabilities found")
                
        except Exception as e:
            print(f"‚ùå Error scanning directory traversal: {e}")
    
    def scan_sensitive_files(self):
        """Scan for exposed sensitive files"""
        print("\nüîç Scanning for exposed sensitive files...")
        
        sensitive_files = [
            '/.htaccess',
            '/.env',
            '/config.php',
            '/wp-config.php',
            '/backup.sql',
            '/database.sql',
            '/admin.php',
            '/phpinfo.php',
            '/test.php',
            '/info.php',
            '/robots.txt',
            '/sitemap.xml',
            '/crossdomain.xml',
            '/clientaccesspolicy.xml'
        ]
        
        exposed_files = []
        
        for file_path in sensitive_files:
            try:
                response = self.session.get(f"{self.base_url}{file_path}", timeout=5)
                if response.status_code == 200:
                    exposed_files.append(f"Exposed file: {file_path}")
            except Exception:
                continue
        
        if exposed_files:
            print("‚ùå Exposed Sensitive Files:")
            for file in exposed_files:
                print(f"   {file}")
            self.vulnerabilities.extend(exposed_files)
        else:
            print("‚úÖ No sensitive files exposed")
    
    def scan_ssl_tls(self):
        """Scan SSL/TLS configuration (if HTTPS)"""
        print("\nüîç Scanning SSL/TLS configuration...")
        
        if self.base_url.startswith('https://'):
            try:
                import ssl
                import socket
                
                hostname = urlparse(self.base_url).hostname
                port = urlparse(self.base_url).port or 443
                
                context = ssl.create_default_context()
                with socket.create_connection((hostname, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        cert = ssock.getpeercert()
                        version = ssock.version()
                        
                        print(f"‚úÖ SSL/TLS Version: {version}")
                        print(f"‚úÖ Certificate Subject: {cert.get('subject', 'Unknown')}")
                        print(f"‚úÖ Certificate Issuer: {cert.get('issuer', 'Unknown')}")
                        
                        # Check certificate expiration
                        import datetime
                        not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        days_until_expiry = (not_after - datetime.datetime.now()).days
                        
                        if days_until_expiry < 30:
                            print(f"‚ö†Ô∏è  Certificate expires in {days_until_expiry} days")
                            self.vulnerabilities.append(f"SSL certificate expires soon: {days_until_expiry} days")
                        else:
                            print(f"‚úÖ Certificate valid for {days_until_expiry} days")
                            
            except Exception as e:
                print(f"‚ùå SSL/TLS scan failed: {e}")
        else:
            print("‚ÑπÔ∏è  HTTP detected - SSL/TLS scan skipped")
    
    def generate_report(self):
        """Generate vulnerability report"""
        print("\n" + "="*60)
        print("üìã VULNERABILITY SCAN REPORT")
        print("="*60)
        
        if self.vulnerabilities:
            print(f"‚ùå Total Vulnerabilities Found: {len(self.vulnerabilities)}")
            print("\nüîç Vulnerability Details:")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"{i}. {vuln}")
            
            print(f"\n‚ö†Ô∏è  Security Score: {max(0, 100 - len(self.vulnerabilities) * 10)}/100")
            print("üîß Recommendations:")
            print("   1. Fix all missing security headers")
            print("   2. Implement proper input validation")
            print("   3. Use parameterized queries for database operations")
            print("   4. Remove or secure exposed sensitive files")
            print("   5. Implement HTTPS with proper SSL configuration")
        else:
            print("üéâ No vulnerabilities found!")
            print("‚úÖ Security Score: 100/100")
            print("üèÜ Your website appears to be secure!")
    
    def run_full_scan(self):
        """Run complete vulnerability scan"""
        print("üöÄ Starting Life Alliance Website Vulnerability Scan")
        print(f"üéØ Target: {self.base_url}")
        print("="*60)
        
        self.scan_headers()
        self.scan_xss()
        self.scan_sql_injection()
        self.scan_directory_traversal()
        self.scan_sensitive_files()
        self.scan_ssl_tls()
        self.generate_report()

def main():
    """Main function"""
    import argparse
    
    parser = argparse.ArgumentParser(description='Life Alliance Website Vulnerability Scanner')
    parser.add_argument('--url', default='http://localhost:8000', 
                       help='URL to scan (default: http://localhost:8000)')
    parser.add_argument('--output', help='Output file for detailed report')
    
    args = parser.parse_args()
    
    scanner = VulnerabilityScanner(args.url)
    scanner.run_full_scan()
    
    if args.output:
        with open(args.output, 'w') as f:
            f.write("Life Alliance Website Vulnerability Report\n")
            f.write("="*50 + "\n\n")
            for vuln in scanner.vulnerabilities:
                f.write(f"- {vuln}\n")
        print(f"\nüìÑ Detailed report saved to: {args.output}")

if __name__ == "__main__":
    main()
